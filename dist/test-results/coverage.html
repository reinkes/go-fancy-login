
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">fancy-login/cmd/main.go (6.3%)</option>
				
				<option value="file1">fancy-login/internal/aws/aws.go (0.0%)</option>
				
				<option value="file2">fancy-login/internal/config/config.go (18.2%)</option>
				
				<option value="file3">fancy-login/internal/k8s/k8s.go (0.0%)</option>
				
				<option value="file4">fancy-login/internal/utils/logger.go (38.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "strings"

        "fancy-login/internal/aws"
        "fancy-login/internal/config"
        "fancy-login/internal/k8s"
        "fancy-login/internal/utils"
)

var (
        // Build-time variables (set via -ldflags)
        version   = "dev"
        buildTime = "unknown"
        gitCommit = "unknown"

        // Command-line flags
        verbose       = flag.Bool("v", false, "Enable verbose output")
        k9sFlag       = flag.Bool("k", false, "Auto-launch k9s without prompting (for DEVENG profiles)")
        forceAWSLogin = flag.Bool("force-aws-login", false, "Force AWS SSO login even if a valid session exists")
        helpFlag      = flag.Bool("h", false, "Show help message")
        versionFlag   = flag.Bool("version", false, "Show version information")
)

func main() <span class="cov0" title="0">{
        flag.BoolVar(verbose, "verbose", false, "Enable verbose output")
        flag.BoolVar(k9sFlag, "k9s", false, "Auto-launch k9s without prompting (for DEVENG profiles)")
        flag.BoolVar(helpFlag, "help", false, "Show help message")
        flag.Parse()

        if *versionFlag </span><span class="cov0" title="0">{
                showVersion()
                return
        }</span>

        <span class="cov0" title="0">if *helpFlag </span><span class="cov0" title="0">{
                showHelp()
                return
        }</span>

        // Initialize configuration
        <span class="cov0" title="0">cfg := config.NewConfig()
        cfg.FancyVerbose = *verbose
        cfg.ForceAWSLogin = *forceAWSLogin
        cfg.UseK9S = *k9sFlag

        // Set debug mode
        if cfg.FancyDebug </span><span class="cov0" title="0">{
                fmt.Println("Debug mode enabled")
        }</span>

        // Initialize logger
        <span class="cov0" title="0">logger := utils.NewLogger(cfg.FancyVerbose)

        // Initialize managers
        awsManager := aws.NewAWSManager(cfg, logger)
        k8sManager := k8s.NewK8sManager(cfg, logger)

        // Variables to aggregate results
        var k8sContextResult string
        var ecrResult string
        var ecrAttempted bool
        var accountIDSummary string

        // Select AWS profile
        awsProfile, err := awsManager.SelectAWSProfile()
        if err != nil </span><span class="cov0" title="0">{
                logger.Die(fmt.Sprintf("Failed to select AWS profile: %v", err))
        }</span>

        // Set AWS_PROFILE environment variable for this process
        <span class="cov0" title="0">os.Setenv("AWS_PROFILE", awsProfile)

        // Handle AWS SSO login
        if err := awsManager.HandleAWSLogin(awsProfile, cfg.ForceAWSLogin); err != nil </span><span class="cov0" title="0">{
                logger.Die(fmt.Sprintf("AWS login failed: %v", err))
        }</span>

        // Select Kubernetes context and get summary string
        <span class="cov0" title="0">k8sContextResult, err = k8sManager.SelectKubernetesContext(awsProfile)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogWarning(fmt.Sprintf("Kubernetes context selection failed: %v", err))
                k8sContextResult = fmt.Sprintf("%süå± Kubernetes Context:%s (failed to select)", config.Green, config.Reset)
        }</span>

        // Always get AWS account ID for summary
        <span class="cov0" title="0">if accountID, err := awsManager.GetAccountID(awsProfile); err == nil </span><span class="cov0" title="0">{
                accountIDSummary = accountID
        }</span>

        // Handle ECR login only for _DEV_ profiles
        <span class="cov0" title="0">if err := awsManager.HandleECRLogin(awsProfile); err != nil </span><span class="cov0" title="0">{
                ecrResult = fmt.Sprintf("%süê≥ ECR login: failed%s", config.Red, config.Reset)
                ecrAttempted = true
                logger.FancyLog(fmt.Sprintf("ECR login failed: %v", err))
        }</span> else<span class="cov0" title="0"> if awsProfile != "" &amp;&amp; containsDev(awsProfile) </span><span class="cov0" title="0">{
                ecrResult = fmt.Sprintf("%süê≥ ECR login: successful%s", config.Green, config.Reset)
                ecrAttempted = true
        }</span>

        // Show summary before k9s prompt (unless verbose)
        <span class="cov0" title="0">if !cfg.FancyVerbose </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Printf("%sü¶Ñ  %sFancy Login Summary%s\n", config.Yellow, config.Bold, config.Reset)
                fmt.Printf("%s‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ%s\n", config.Yellow, config.Reset)
                fmt.Printf("%süîë AWS Profile:%s %s%s%s\n", config.Yellow, config.Reset, config.Bold, awsProfile, config.Reset)
                if k8sContextResult != "" </span><span class="cov0" title="0">{
                        fmt.Println(k8sContextResult)
                }</span>
                <span class="cov0" title="0">if ecrAttempted </span><span class="cov0" title="0">{
                        fmt.Println(ecrResult)
                }</span>
                <span class="cov0" title="0">if accountIDSummary != "" </span><span class="cov0" title="0">{
                        fmt.Printf("%s‚òÅÔ∏è  AWS Account ID:%s %s%s%s\n", config.Cyan, config.Reset, config.Bold, accountIDSummary, config.Reset)
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ%s\n", config.Yellow, config.Reset)
                fmt.Println()</span>
        }

        // Handle k9s launch
        <span class="cov0" title="0">if err := k8sManager.HandleK9sLaunch(awsProfile); err != nil </span><span class="cov0" title="0">{
                logger.LogError(fmt.Sprintf("Failed to launch k9s: %v", err))
        }</span>

        <span class="cov0" title="0">logger.LogCompletion("Script execution completed.")</span>
}

func showHelp() <span class="cov0" title="0">{
        fmt.Printf(`Usage: %s [OPTIONS]

OPTIONS:
  -k, --k9s           Auto-launch k9s without prompting (for DEVENG profiles)
  -v, --verbose       Enable verbose output
  --force-aws-login   Force AWS SSO login even if a valid session exists
  -h, --help          Show this help message
  --version           Show version information

Description:
  Interactive tool for AWS SSO login and Kubernetes context selection.
  Automatically handles ECR login for development profiles and provides
  namespace-aware k9s integration.
  
  When using -k flag with DEVENG profiles, k9s will launch automatically
  in the derived namespace without user confirmation.
  Use -v to enable verbose output for debugging.
  Use --force-aws-login to always perform AWS SSO login, even if a valid session exists.

Version: %s
Build Time: %s
Git Commit: %s
`, os.Args[0], version, buildTime, gitCommit)
}</span>

func showVersion() <span class="cov1" title="1">{
        fmt.Printf("fancy-login-go version %s\n", version)
        fmt.Printf("Build time: %s\n", buildTime)
        fmt.Printf("Git commit: %s\n", gitCommit)
}</span>

func containsDev(profile string) bool <span class="cov10" title="13">{
        return strings.Contains(profile, "_DEV_")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package aws

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "runtime"
        "strings"

        "fancy-login/internal/config"
        "fancy-login/internal/utils"
)

// AWSManager handles AWS operations
type AWSManager struct {
        config *config.Config
        logger *utils.Logger
}

// NewAWSManager creates a new AWS manager
func NewAWSManager(cfg *config.Config, logger *utils.Logger) *AWSManager <span class="cov0" title="0">{
        return &amp;AWSManager{
                config: cfg,
                logger: logger,
        }
}</span>

// SelectAWSProfile allows user to select an AWS profile using fzf
func (aws *AWSManager) SelectAWSProfile() (string, error) <span class="cov0" title="0">{
        aws.logger.FancyLog("Select an AWS Profile:")

        profiles, err := aws.getAWSProfiles()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(profiles) == 0 </span><span class="cov0" title="0">{
                aws.logger.Die("No AWS profiles found in ~/.aws/config")
        }</span>

        <span class="cov0" title="0">aws.logger.FancyLog(fmt.Sprintf("Profiles found: %v", profiles))

        // Use fzf to select profile
        cmd := exec.Command("fzf", "--prompt=Select AWS Profile: ")
        cmd.Stdin = strings.NewReader(strings.Join(profiles, "\n"))

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("profile selection failed: %w", err)
        }</span>

        <span class="cov0" title="0">profile := strings.TrimSpace(string(output))
        if profile == "" </span><span class="cov0" title="0">{
                aws.logger.Die("No profile selected. Exiting.")
        }</span>

        // Remove "profile " prefix if present
        <span class="cov0" title="0">profile = strings.TrimPrefix(profile, "profile ")

        aws.logger.FancyLog(fmt.Sprintf("Profile selected: %s", profile))

        // Export profile to temp file for shell integration
        if err := aws.exportProfileToTemp(profile); err != nil </span><span class="cov0" title="0">{
                aws.logger.LogWarning(fmt.Sprintf("Failed to export profile to temp file: %v", err))
        }</span>

        <span class="cov0" title="0">aws.logger.LogSuccess(fmt.Sprintf("Selected AWS Profile: %s", profile))
        return profile, nil</span>
}

// HandleAWSLogin checks and handles AWS SSO authentication
func (aws *AWSManager) HandleAWSLogin(profile string, forceLogin bool) error <span class="cov0" title="0">{
        aws.logger.FancyLog(fmt.Sprintf("Checking AWS SSO session for profile %s...", profile))

        if !forceLogin </span><span class="cov0" title="0">{
                if aws.isSessionValid(profile) </span><span class="cov0" title="0">{
                        aws.logger.LogSuccess(fmt.Sprintf("AWS SSO session is still valid for %s.", profile))
                        return nil
                }</span>
        }

        <span class="cov0" title="0">isSSO, err := aws.isSSOMProfile(profile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if isSSO </span><span class="cov0" title="0">{
                return aws.performSSOMLogin(profile)
        }</span>

        <span class="cov0" title="0">aws.logger.LogWarning(fmt.Sprintf("Unable to authenticate with profile %s. This might not be an SSO profile.", profile))

        fmt.Printf("%sDo you want to continue anyway? (y/n): %s", config.Cyan, config.Reset)
        var response string
        fmt.Scanln(&amp;response)

        if response != "y" </span><span class="cov0" title="0">{
                aws.logger.Die("User chose to exit due to authentication issues.")
        }</span>

        <span class="cov0" title="0">aws.logger.LogWarning("Continuing with potentially invalid credentials...")
        return nil</span>
}

// HandleECRLogin performs ECR login for development profiles
func (aws *AWSManager) HandleECRLogin(profile string) error <span class="cov0" title="0">{
        if !strings.Contains(profile, "_DEV_") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">aws.logger.FancyLog("ECR login for DEV profile...")

        accountID, err := aws.getAccountID(profile)
        if err != nil </span><span class="cov0" title="0">{
                aws.logger.LogError("Failed to retrieve AWS account ID. Your session may have expired or is not authenticated.")
                return err
        }</span>

        <span class="cov0" title="0">region := os.Getenv("AWS_REGION")
        if region == "" </span><span class="cov0" title="0">{
                region = aws.config.DefaultRegion
        }</span>

        <span class="cov0" title="0">aws.logger.FancyLog(fmt.Sprintf("Account ID: %s, Region: %s", accountID, region))

        var spinner *utils.Spinner
        if !aws.config.FancyVerbose </span><span class="cov0" title="0">{
                spinner = utils.NewSpinner("üê≥ Logging in to ECR...")
                spinner.Start()
        }</span>

        // Get ECR login password and login to docker
        <span class="cov0" title="0">cmd1 := exec.Command("aws", "ecr", "get-login-password", "--region", region, "--profile", profile)
        cmd2 := exec.Command("docker", "login", "--username", "AWS", "--password-stdin",
                fmt.Sprintf("%s.dkr.ecr.%s.amazonaws.com", accountID, region))

        cmd2.Stdin, _ = cmd1.StdoutPipe()

        if err := cmd1.Start(); err != nil </span><span class="cov0" title="0">{
                if spinner != nil </span><span class="cov0" title="0">{
                        spinner.Stop()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to start ECR login command: %w", err)</span>
        }

        <span class="cov0" title="0">if err := cmd2.Start(); err != nil </span><span class="cov0" title="0">{
                if spinner != nil </span><span class="cov0" title="0">{
                        spinner.Stop()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to start docker login command: %w", err)</span>
        }

        <span class="cov0" title="0">if err := cmd1.Wait(); err != nil </span><span class="cov0" title="0">{
                if spinner != nil </span><span class="cov0" title="0">{
                        spinner.Stop()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("ECR get-login-password failed: %w", err)</span>
        }

        <span class="cov0" title="0">if err := cmd2.Wait(); err != nil </span><span class="cov0" title="0">{
                if spinner != nil </span><span class="cov0" title="0">{
                        spinner.Stop()
                }</span>
                <span class="cov0" title="0">aws.logger.LogError("ECR login failed.")
                return fmt.Errorf("docker login failed: %w", err)</span>
        }

        <span class="cov0" title="0">if spinner != nil </span><span class="cov0" title="0">{
                spinner.Stop()
        }</span>

        <span class="cov0" title="0">aws.logger.FancyLog("ECR login successful")
        if aws.config.FancyVerbose </span><span class="cov0" title="0">{
                aws.logger.LogSuccess("Docker: Login Succeeded")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAccountID retrieves the AWS account ID for the current profile
func (aws *AWSManager) GetAccountID(profile string) (string, error) <span class="cov0" title="0">{
        return aws.getAccountID(profile)
}</span>

// getAWSProfiles reads AWS profiles from ~/.aws/config
func (aws *AWSManager) getAWSProfiles() ([]string, error) <span class="cov0" title="0">{
        homeDir, _ := os.UserHomeDir()
        configPath := filepath.Join(homeDir, ".aws", "config")

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open AWS config: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var profiles []string
        re := regexp.MustCompile(`^\[profile\s+(.+)\]`)

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                matches := re.FindStringSubmatch(line)
                if len(matches) == 2 </span><span class="cov0" title="0">{
                        profiles = append(profiles, matches[1])
                }</span>
        }

        <span class="cov0" title="0">return profiles, scanner.Err()</span>
}

// isSessionValid checks if the AWS session is valid for the given profile
func (aws *AWSManager) isSessionValid(profile string) bool <span class="cov0" title="0">{
        cmd := exec.Command("aws", "sts", "get-caller-identity", "--profile", profile, "--query", "Account", "--output", "text")
        cmd.Stdout = nil
        cmd.Stderr = nil
        return cmd.Run() == nil
}</span>

// isSSOMProfile checks if the profile is an SSO profile
func (aws *AWSManager) isSSOMProfile(profile string) (bool, error) <span class="cov0" title="0">{
        homeDir, _ := os.UserHomeDir()
        configPath := filepath.Join(homeDir, ".aws", "config")

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        inProfile := false
        profilePattern := fmt.Sprintf("[profile %s]", profile)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                if line == profilePattern </span><span class="cov0" title="0">{
                        inProfile = true
                        continue</span>
                }

                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; inProfile </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if inProfile &amp;&amp; strings.Contains(line, "sso_") </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, scanner.Err()</span>
}

// performSSOMLogin performs AWS SSO login
func (aws *AWSManager) performSSOMLogin(profile string) error <span class="cov0" title="0">{
        aws.logger.FancyLog(fmt.Sprintf("SSO profile detected. Session expired or not found for %s.", profile))
        aws.logger.FancyLog(fmt.Sprintf("Attempting SSO login for profile %s...", profile))

        var cmd *exec.Cmd
        if !aws.config.FancyVerbose </span><span class="cov0" title="0">{
                spinner := utils.NewSpinner("üîë AWS SSO login...")
                spinner.Start()

                cmd = exec.Command("aws", "sso", "login", "--profile", profile)
                cmd.Stdout = nil
                cmd.Stderr = nil

                err := cmd.Run()
                spinner.Stop()

                if err != nil </span><span class="cov0" title="0">{
                        aws.logger.Die(fmt.Sprintf("AWS SSO login failed for %s.", profile))
                }</span>
        } else<span class="cov0" title="0"> {
                cmd = exec.Command("aws", "sso", "login", "--profile", profile)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        aws.logger.Die(fmt.Sprintf("AWS SSO login failed for %s.", profile))
                }</span>
        }

        // Verify login
        <span class="cov0" title="0">if !aws.isSessionValid(profile) </span><span class="cov0" title="0">{
                aws.logger.Die(fmt.Sprintf("AWS SSO login verification failed for %s.", profile))
        }</span>

        <span class="cov0" title="0">aws.logger.LogSuccess(fmt.Sprintf("AWS SSO login successful for %s.", profile))
        return nil</span>
}

// getAccountID retrieves the AWS account ID
func (aws *AWSManager) getAccountID(profile string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("aws", "sts", "get-caller-identity", "--profile", profile, "--query", "Account", "--output", "text")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// exportProfileToTemp exports the AWS profile to a temp file for shell integration
func (aws *AWSManager) exportProfileToTemp(profile string) error <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Create both PowerShell and batch files for Windows
                psContent := fmt.Sprintf("$env:AWS_PROFILE=\"%s\"\n", profile)
                if err := os.WriteFile(aws.config.AWSProfileTemp, []byte(psContent), 0644); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Also create a .bat file for Command Prompt users
                <span class="cov0" title="0">batFile := strings.Replace(aws.config.AWSProfileTemp, ".ps1", ".bat", 1)
                batContent := fmt.Sprintf("set AWS_PROFILE=%s\n", profile)
                return os.WriteFile(batFile, []byte(batContent), 0644)</span>
        } else<span class="cov0" title="0"> {
                // Unix shell script format
                content := fmt.Sprintf("export AWS_PROFILE=%s\n", profile)
                return os.WriteFile(aws.config.AWSProfileTemp, []byte(content), 0644)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "strings"
)

// Colors for terminal output
const (
        Green  = "\033[0;32m"
        Yellow = "\033[1;33m"
        Cyan   = "\033[1;36m"
        Red    = "\033[0;31m"
        Reset  = "\033[0m"
        Bold   = "\033[1m"
)

// Config holds all configuration for fancy-login
type Config struct {
        NamespaceConfig string
        AWSProfileTemp  string
        DefaultRegion   string
        FancyVerbose    bool
        ForceAWSLogin   bool
        UseK9S          bool
        FancyDebug      bool
        BinDir          string
        AWSDir          string
        KubeDir         string
}

// NewConfig creates a new configuration with defaults
func NewConfig() *Config <span class="cov6" title="10">{
        homeDir, _ := os.UserHomeDir()

        // Platform-specific paths
        var binDir string
        var awsProfileTemp string

        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Windows: Use AppData\Local for binaries, temp dir for profile scripts
                binDir = filepath.Join(homeDir, "AppData", "Local", "fancy-login")
                awsProfileTemp = filepath.Join(os.TempDir(), "aws_profile.ps1")
        }</span> else<span class="cov6" title="10"> {
                // Unix-like (Linux, macOS): Use .local/bin
                binDir = filepath.Join(homeDir, ".local", "bin")
                awsProfileTemp = "/tmp/aws_profile.sh"
        }</span>

        <span class="cov6" title="10">return &amp;Config{
                NamespaceConfig: getEnvWithDefault("FANCY_NAMESPACE_CONFIG", filepath.Join(binDir, ".fancy-namespaces.conf")),
                AWSProfileTemp:  getEnvWithDefault("FANCY_PROFILE_TEMP", awsProfileTemp),
                DefaultRegion:   getEnvWithDefault("FANCY_DEFAULT_REGION", "eu-central-1"),
                FancyVerbose:    getEnvBool("FANCY_VERBOSE"),
                FancyDebug:      getEnvBool("FANCY_DEBUG"),
                BinDir:          getEnvWithDefault("FANCY_BIN_DIR", binDir),
                AWSDir:          getEnvWithDefault("FANCY_AWS_DIR", filepath.Join(homeDir, ".aws")),
                KubeDir:         getEnvWithDefault("FANCY_KUBE_DIR", filepath.Join(homeDir, ".kube")),
        }</span>
}

// ContextMapping represents a mapping from AWS profile pattern to k8s context
type ContextMapping struct {
        Pattern string
        Context string
}

// LoadContextMappings loads context mappings from .fancy-contexts.conf
func LoadContextMappings() ([]ContextMapping, error) <span class="cov0" title="0">{
        cfg := NewConfig()
        contextConf := filepath.Join(cfg.BinDir, ".fancy-contexts.conf")

        // Check for local config file first
        if _, err := os.Stat(".fancy-contexts.conf"); err == nil </span><span class="cov0" title="0">{
                contextConf = ".fancy-contexts.conf"
        }</span>

        <span class="cov0" title="0">return parseContextFile(contextConf)</span>
}

// LoadNamespaceMappings loads namespace mappings from .fancy-namespaces.conf
func LoadNamespaceMappings() (map[string]string, error) <span class="cov0" title="0">{
        config := NewConfig()
        return parseNamespaceFile(config.NamespaceConfig)
}</span>

// parseContextFile parses the context configuration file
func parseContextFile(filename string) ([]ContextMapping, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open context config %s: %w", filename, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var mappings []ContextMapping
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        pattern := strings.TrimSpace(parts[0])
                        context := strings.TrimSpace(parts[1])
                        mappings = append(mappings, ContextMapping{
                                Pattern: pattern,
                                Context: context,
                        })
                }</span>
        }

        <span class="cov0" title="0">return mappings, scanner.Err()</span>
}

// parseNamespaceFile parses the namespace configuration file
func parseNamespaceFile(filename string) (map[string]string, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open namespace config %s: %w", filename, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        mappings := make(map[string]string)
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        code := strings.TrimSpace(parts[0])
                        project := strings.TrimSpace(parts[1])
                        mappings[code] = project
                }</span>
        }

        <span class="cov0" title="0">return mappings, scanner.Err()</span>
}

// GetNamespaceFromProfile derives the namespace from AWS profile name
func GetNamespaceFromProfile(profile string, namespaceMappings map[string]string) (string, error) <span class="cov0" title="0">{
        // Match pattern like XXX_YYY_DEVENG
        re := regexp.MustCompile(`^([A-Z]+)_([A-Z]+)_DEVENG$`)
        matches := re.FindStringSubmatch(profile)

        if len(matches) != 3 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("profile %s does not match DEVENG pattern", profile)
        }</span>

        <span class="cov0" title="0">projectCode := matches[1]
        environment := strings.ToLower(matches[2])

        projectName, exists := namespaceMappings[projectCode]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("project code %s not found in namespace config", projectCode)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s-%s", environment, projectName), nil</span>
}

// MatchesPattern checks if a profile matches a wildcard pattern
func MatchesPattern(profile, pattern string) bool <span class="cov0" title="0">{
        // Convert shell-style wildcards to regex
        regexPattern := "^" + strings.ReplaceAll(strings.ReplaceAll(pattern, "*", ".*"), "?", ".") + "$"
        matched, _ := regexp.MatchString(regexPattern, profile)
        return matched
}</span>

// getEnvWithDefault returns environment variable value or default
func getEnvWithDefault(key, defaultValue string) string <span class="cov10" title="60">{
        if value := os.Getenv(key); value != "" </span><span class="cov2" title="2">{
                return value
        }</span>
        <span class="cov9" title="58">return defaultValue</span>
}

// getEnvBool returns environment variable as boolean
func getEnvBool(key string) bool <span class="cov7" title="20">{
        value := os.Getenv(key)
        return value == "1" || value == "true"
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package k8s

import (
        "encoding/base64"
        "fmt"
        "os"
        "os/exec"
        "runtime"
        "strings"

        "fancy-login/internal/config"
        "fancy-login/internal/utils"
)

// K8sManager handles Kubernetes operations
type K8sManager struct {
        config *config.Config
        logger *utils.Logger
}

// NewK8sManager creates a new Kubernetes manager
func NewK8sManager(cfg *config.Config, logger *utils.Logger) *K8sManager <span class="cov0" title="0">{
        return &amp;K8sManager{
                config: cfg,
                logger: logger,
        }
}</span>

// SelectKubernetesContext selects and switches Kubernetes context
func (k8s *K8sManager) SelectKubernetesContext(awsProfile string) (string, error) <span class="cov0" title="0">{
        k8s.logger.FancyLog("Entered select_kubernetes_context")

        if k8s.shouldSkipK8sContext(awsProfile) </span><span class="cov0" title="0">{
                return k8s.handleDEVProfile(awsProfile)
        }</span>

        // Load context mappings
        <span class="cov0" title="0">mappings, err := config.LoadContextMappings()
        if err != nil </span><span class="cov0" title="0">{
                k8s.logger.FancyLog(fmt.Sprintf("Failed to load context mappings: %v", err))
                mappings = []config.ContextMapping{}
        }</span>

        // Check for mapped context
        <span class="cov0" title="0">for _, mapping := range mappings </span><span class="cov0" title="0">{
                if config.MatchesPattern(awsProfile, mapping.Pattern) </span><span class="cov0" title="0">{
                        k8s.logger.FancyLog(fmt.Sprintf("Matched pattern: %s, using context: %s", mapping.Pattern, mapping.Context))

                        if err := k8s.switchK8sContext(mapping.Context); err != nil </span><span class="cov0" title="0">{
                                k8s.logger.LogWarning(fmt.Sprintf("Failed to switch to context %s: %v", mapping.Context, err))
                        }</span>

                        <span class="cov0" title="0">return k8s.formatContextSummary(mapping.Context, awsProfile), nil</span>
                }
        }

        // No mapping found, use fzf to select
        <span class="cov0" title="0">context, err := k8s.selectContextWithFzf()
        if err != nil </span><span class="cov0" title="0">{
                k8s.logger.FancyLog("No context selected or error occurred")
                // Return current context or fallback
                return k8s.getCurrentContextSummary(awsProfile)
        }</span>

        <span class="cov0" title="0">if err := k8s.switchK8sContext(context); err != nil </span><span class="cov0" title="0">{
                k8s.logger.LogWarning(fmt.Sprintf("Failed to switch to context %s: %v", context, err))
        }</span>

        <span class="cov0" title="0">return k8s.formatContextSummary(context, awsProfile), nil</span>
}

// HandleK9sLaunch handles launching k9s for DEVENG profiles
func (k8s *K8sManager) HandleK9sLaunch(awsProfile string) error <span class="cov0" title="0">{
        if !strings.HasSuffix(awsProfile, "DEVENG") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if k8s.config.UseK9S </span><span class="cov0" title="0">{
                return k8s.launchK9sWithNamespace(awsProfile)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n%sDo you want to open k9s in the derived namespace? (y/n): %s", config.Cyan, config.Reset)
        var response string
        fmt.Scanln(&amp;response)

        if response == "y" </span><span class="cov0" title="0">{
                return k8s.launchK9sWithNamespace(awsProfile)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// shouldSkipK8sContext determines if context selection should be skipped for DEV profiles
func (k8s *K8sManager) shouldSkipK8sContext(awsProfile string) bool <span class="cov0" title="0">{
        skip := strings.Contains(awsProfile, "_DEV_")
        k8s.logger.FancyLog(fmt.Sprintf("should_skip_k8s_context: %s matches *_DEV_* = %t", awsProfile, skip))
        return skip
}</span>

// handleDEVProfile handles context selection for DEV profiles
func (k8s *K8sManager) handleDEVProfile(awsProfile string) (string, error) <span class="cov0" title="0">{
        mappings, err := config.LoadContextMappings()
        if err != nil </span><span class="cov0" title="0">{
                k8s.logger.FancyLog(fmt.Sprintf("Failed to load context mappings: %v", err))
                mappings = []config.ContextMapping{}
        }</span>

        <span class="cov0" title="0">var mappedContext string
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                if config.MatchesPattern(awsProfile, mapping.Pattern) </span><span class="cov0" title="0">{
                        mappedContext = mapping.Context
                        break</span>
                }
        }

        // Load namespace mappings
        <span class="cov0" title="0">namespaceMappings, err := config.LoadNamespaceMappings()
        if err != nil </span><span class="cov0" title="0">{
                k8s.logger.FancyLog(fmt.Sprintf("Failed to load namespace mappings: %v", err))
                namespaceMappings = make(map[string]string)
        }</span>

        // Try to get namespace from profile
        <span class="cov0" title="0">namespace, err := config.GetNamespaceFromProfile(awsProfile, namespaceMappings)
        if err == nil </span><span class="cov0" title="0">{
                k8s.setITerm2Namespace(namespace)
                if mappedContext != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%süå± Kubernetes Context:%s %s%s%s %s(ns: %s)%s",
                                config.Green, config.Reset, config.Bold, mappedContext, config.Reset,
                                config.Cyan, namespace, config.Reset), nil
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%süå± Kubernetes Context:%s %s(ns: %s)%s",
                        config.Green, config.Reset, config.Cyan, namespace, config.Reset), nil</span>
        }

        <span class="cov0" title="0">if mappedContext != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%süå± Kubernetes Context:%s %s%s%s",
                        config.Green, config.Reset, config.Bold, mappedContext, config.Reset), nil
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%süå± Kubernetes Context:%s (skipped for DEV profile)",
                config.Green, config.Reset), nil</span>
}

// selectContextWithFzf uses fzf to select a Kubernetes context
func (k8s *K8sManager) selectContextWithFzf() (string, error) <span class="cov0" title="0">{
        k8s.logger.FancyLog("Selecting Kubernetes Context...")

        // Get available contexts
        cmd := exec.Command("kubectl", "config", "get-contexts", "-o", "name")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get contexts: %w", err)
        }</span>

        <span class="cov0" title="0">contexts := strings.TrimSpace(string(output))
        if contexts == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no contexts available")
        }</span>

        // Use fzf to select
        <span class="cov0" title="0">fzfCmd := exec.Command("fzf", "--prompt=Select Kubernetes Context: ")
        fzfCmd.Stdin = strings.NewReader(contexts)

        result, err := fzfCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">context := strings.TrimSpace(string(result))
        k8s.logger.FancyLog(fmt.Sprintf("K8s context selected: %s", context))

        return context, nil</span>
}

// switchK8sContext switches to the specified Kubernetes context
func (k8s *K8sManager) switchK8sContext(context string) error <span class="cov0" title="0">{
        if k8s.config.FancyVerbose </span><span class="cov0" title="0">{
                k8s.logger.LogInfo(fmt.Sprintf("Switching to Kubernetes context: %s", context))
                cmd := exec.Command("kubectl", "config", "use-context", context)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                return cmd.Run()
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("kubectl", "config", "use-context", context)
        cmd.Stdout = nil
        cmd.Stderr = nil
        return cmd.Run()</span>
}

// getCurrentContextSummary returns the current context summary
func (k8s *K8sManager) getCurrentContextSummary(awsProfile string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("kubectl", "config", "current-context")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%süå± Kubernetes Context:%s (none selected)",
                        config.Green, config.Reset), nil
        }</span>

        <span class="cov0" title="0">currentContext := strings.TrimSpace(string(output))
        return k8s.formatContextSummary(currentContext, awsProfile), nil</span>
}

// formatContextSummary formats the context summary with namespace if available
func (k8s *K8sManager) formatContextSummary(context, awsProfile string) string <span class="cov0" title="0">{
        namespaceMappings, err := config.LoadNamespaceMappings()
        if err != nil </span><span class="cov0" title="0">{
                namespaceMappings = make(map[string]string)
        }</span>

        <span class="cov0" title="0">namespace, err := config.GetNamespaceFromProfile(awsProfile, namespaceMappings)
        if err == nil </span><span class="cov0" title="0">{
                k8s.setITerm2Namespace(namespace)
                return fmt.Sprintf("%süå± Kubernetes Context:%s %s%s%s %s(ns: %s)%s",
                        config.Green, config.Reset, config.Bold, context, config.Reset,
                        config.Cyan, namespace, config.Reset)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%süå± Kubernetes Context:%s %s%s%s",
                config.Green, config.Reset, config.Bold, context, config.Reset)</span>
}

// setITerm2Namespace sets the terminal tab title and badge (cross-platform)
func (k8s *K8sManager) setITerm2Namespace(namespace string) <span class="cov0" title="0">{
        if namespace == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                // macOS iTerm2
                if os.Getenv("TERM_PROGRAM") == "iTerm.app" </span><span class="cov0" title="0">{
                        // Set tab title
                        fmt.Printf("\033]1;ns:%s\007", namespace)

                        // Set badge
                        badge := fmt.Sprintf("üü¢ ns:%s", namespace)
                        encoded := base64.StdEncoding.EncodeToString([]byte(badge))
                        fmt.Printf("\033]1337;SetBadgeFormat=%s\a", encoded)
                }</span>
        case "windows":<span class="cov0" title="0">
                // Windows Terminal
                if os.Getenv("WT_SESSION") != "" </span><span class="cov0" title="0">{
                        // Set tab title for Windows Terminal
                        fmt.Printf("\033]0;ns:%s\007", namespace)
                }</span>
        default:<span class="cov0" title="0">
                // Linux terminals (most support standard title escape sequence)
                fmt.Printf("\033]0;ns:%s\007", namespace)</span>
        }
}

// launchK9sWithNamespace launches k9s with the derived namespace
func (k8s *K8sManager) launchK9sWithNamespace(awsProfile string) error <span class="cov0" title="0">{
        namespaceMappings, err := config.LoadNamespaceMappings()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load namespace mappings: %w", err)
        }</span>

        <span class="cov0" title="0">namespace, err := config.GetNamespaceFromProfile(awsProfile, namespaceMappings)
        if err != nil </span><span class="cov0" title="0">{
                k8s.logger.LogError(fmt.Sprintf("Unable to derive namespace from profile: %s", awsProfile))
                return err
        }</span>

        <span class="cov0" title="0">k8s.logger.FancyLog(fmt.Sprintf("Launching k9s in %s.", namespace))

        cmd := exec.Command("k9s", "-n", namespace)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin

        // Inherit current environment and set AWS_PROFILE
        cmd.Env = os.Environ()
        cmd.Env = append(cmd.Env, fmt.Sprintf("AWS_PROFILE=%s", awsProfile))

        return cmd.Run()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package utils

import (
        "fmt"
        "os"
        "time"

        "fancy-login/internal/config"
)

// Logger provides logging functionality
type Logger struct {
        verbose bool
}

// NewLogger creates a new logger instance
func NewLogger(verbose bool) *Logger <span class="cov10" title="13">{
        return &amp;Logger{verbose: verbose}
}</span>

// FancyLog prints debug messages when verbose mode is enabled
func (l *Logger) FancyLog(message string) <span class="cov6" title="5">{
        if l.verbose </span><span class="cov4" title="3">{
                fmt.Printf("[fancy-login] %s\n", message)
        }</span>
}

// LogInfo prints informational messages
func (l *Logger) LogInfo(message string) <span class="cov3" title="2">{
        fmt.Printf("%süîπ %s%s\n", config.Cyan, message, config.Reset)
}</span>

// LogSuccess prints success messages (only in verbose mode)
func (l *Logger) LogSuccess(message string) <span class="cov6" title="5">{
        if l.verbose </span><span class="cov4" title="3">{
                fmt.Printf("%s‚úÖ %s%s\n", config.Green, message, config.Reset)
        }</span>
}

// LogWarning prints warning messages
func (l *Logger) LogWarning(message string) <span class="cov3" title="2">{
        fmt.Printf("%s‚ö†Ô∏è %s%s\n", config.Yellow, message, config.Reset)
}</span>

// LogError prints error messages
func (l *Logger) LogError(message string) <span class="cov3" title="2">{
        fmt.Printf("%s‚ùå %s%s\n", config.Red, message, config.Reset)
}</span>

// LogCompletion prints completion messages (only in verbose mode)
func (l *Logger) LogCompletion(message string) <span class="cov0" title="0">{
        if l.verbose </span><span class="cov0" title="0">{
                fmt.Printf("\n%süéâ %s%s\n", config.Cyan, message, config.Reset)
        }</span>
}

// Die prints error and exits
func (l *Logger) Die(message string) <span class="cov0" title="0">{
        l.LogError(message)
        os.Exit(1)
}</span>

// Spinner represents a loading spinner
type Spinner struct {
        message string
        chars   []rune
        index   int
        running bool
}

// NewSpinner creates a new spinner
func NewSpinner(message string) *Spinner <span class="cov0" title="0">{
        return &amp;Spinner{
                message: message,
                chars:   []rune{'|', '/', '-', '\\'},
                index:   0,
                running: false,
        }
}</span>

// Start begins the spinner animation
func (s *Spinner) Start() <span class="cov0" title="0">{
        s.running = true
        go func() </span><span class="cov0" title="0">{
                for s.running </span><span class="cov0" title="0">{
                        fmt.Printf("\r%s%s %c %s", config.Cyan, s.message, s.chars[s.index], config.Reset)
                        s.index = (s.index + 1) % len(s.chars)
                        time.Sleep(100 * time.Millisecond)
                }</span>
        }()
}

// Stop stops the spinner and clears the line
func (s *Spinner) Stop() <span class="cov0" title="0">{
        s.running = false
        fmt.Printf("\r%60s\r", "") // Clear the line
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
